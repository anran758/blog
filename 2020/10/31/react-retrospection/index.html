<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/blog/images/favicon/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon/favicon-16x16.png"><link rel="mask-icon" href="/blog/images/favicon/logo.svg" color="#222"><link rel="manifest" href="/blog/images/favicon/site.webmanifest"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="hfSxUMVDQ0d4JZmyWsUce4uMULHxHXQxxCLYVk3cIbs"><meta name="msvalidate.01" content="D0E8CE815DEAA11708C153218034AA8E"><meta name="baidu-site-verification" content="CtPpLH5dio"><link rel="stylesheet" href="/blog/css/main.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"anran758.github.io",root:"/blog/",scheme:"Muse",version:"8.0.0-rc.3",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!0,color:"#222",save:"manual"},fancybox:!1,mediumzoom:!0,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!0,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!0,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="使用 React 进行项目开发也有好几个项目了，趁着最近有空来对 React 的知识做一个简单的复盘。"><meta property="og:type" content="article"><meta property="og:title" content="React 知识回顾 (使用篇)"><meta property="og:url" content="https://anran758.github.io/blog/2020/10/31/react-retrospection/"><meta property="og:site_name" content="Anran758&#39;s blog"><meta property="og:description" content="使用 React 进行项目开发也有好几个项目了，趁着最近有空来对 React 的知识做一个简单的复盘。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://anran758.github.io/blog/2020/10/31/react-retrospection/banner.png"><meta property="og:image" content="https://anran758.github.io/blog/2020/10/31/react-retrospection/react-lifecycle.png"><meta property="article:published_time" content="2020-10-31T12:19:22.000Z"><meta property="article:modified_time" content="2021-10-04T09:19:41.957Z"><meta property="article:author" content="anran758"><meta property="article:tag" content="JavaScript"><meta property="article:tag" content="React"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://anran758.github.io/blog/2020/10/31/react-retrospection/banner.png"><link rel="canonical" href="https://anran758.github.io/blog/2020/10/31/react-retrospection/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>React 知识回顾 (使用篇) | Anran758's blog</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-99223334-1"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-99223334-1")}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b333b085e93f238859c899fd8ca5bd3f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/blog/atom.xml" title="Anran758's blog" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/blog/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Anran758's blog</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时间轴</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/anran758/blog" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anran758.github.io/blog/2020/10/31/react-retrospection/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://avatars3.githubusercontent.com/u/23024075?s=96&v=4"><meta itemprop="name" content="anran758"><meta itemprop="description" content="web 开发的碎碎念"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Anran758's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">React 知识回顾 (使用篇)</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-10-31 20:19:22" itemprop="dateCreated datePublished" datetime="2020-10-31T20:19:22+08:00">2020-10-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-10-04 17:19:41" itemprop="dateModified" datetime="2021-10-04T17:19:41+08:00">2021-10-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/blog/categories/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a> </span></span><span id="/blog/2020/10/31/react-retrospection/" class="post-meta-item leancloud_visitors" data-flag-title="React 知识回顾 (使用篇)" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Disqus：</span> <a title="disqus" href="/blog/2020/10/31/react-retrospection/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/10/31/react-retrospection/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>12k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>15 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><img data-src="/blog/2020/10/31/react-retrospection/banner.png"><p>使用 React 进行项目开发也有好几个项目了，趁着最近有空来对 React 的知识做一个简单的复盘。</p><span id="more"></span><details><summary>完整目录概览</summary><ul><li><a href="#react-%E6%98%AF%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BF%98%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AE%83%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E7%89%B9%E7%82%B9%E5%90%97">React 是单向数据流还是双向数据流？它还有其他特点吗？</a></li><li><a href="#setstate">setState</a><ul><li><a href="#react-%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E6%9D%A5%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE">React 通过什么方式来更新数据</a></li><li><a href="#react-%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9-state-%E5%90%97">React 不能直接修改 State 吗？</a></li><li><a href="#setstate-%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84">setState 是同步还是异步的？</a></li><li><a href="#setstate-%E5%B0%8F%E6%B5%8B">setState 小测</a></li></ul></li><li><a href="#react-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">React 生命周期</a><ul><li><a href="#constructor-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">constructor (构造函数)</a></li><li><a href="#static-getderivedstatefromprops">static getDerivedStateFromProps</a></li><li><a href="#shouldcomponentupdate">shouldComponentUpdate</a></li><li><a href="#render">render</a></li><li><a href="#getsnapshotbeforeupdate">getSnapshotBeforeUpdate</a></li><li><a href="#componentdidmount">componentDidMount</a></li><li><a href="#componentdidupdate">componentDidUpdate</a></li><li><a href="#componentwillunmount">componentWillUnmount</a></li><li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%98%B6%E6%AE%B5">生命周期阶段</a></li><li><a href="#%E5%85%B6%E4%BB%96%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">其他生命周期</a></li></ul></li><li><a href="#react-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1">React 组件通信</a><ul><li><a href="#reactcontext-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8">React.Context 怎么使用</a></li></ul></li><li><a href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8E%E7%B1%BB%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">函数组件是什么？与类组件有什么区别？</a></li><li><a href="#hooks">Hooks</a><ul><li><a href="#hook-vs-class">Hook vs class</a></li><li><a href="#hooks-%E7%9A%84%E4%BD%BF%E7%94%A8">Hooks 的使用</a></li><li><a href="#hook-%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%AE%E5%BC%82">Hook 之间的一些差异</a></li><li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89-hook-%E7%9A%84%E4%BD%BF%E7%94%A8">自定义 Hook 的使用</a></li><li><a href="#hook-%E4%BD%BF%E7%94%A8%E7%BA%A6%E6%9D%9F">Hook 使用约束</a></li><li><a href="#class-%E7%BB%84%E4%BB%B6%E4%B8%8E-hook-%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E4%B8%8E%E8%BD%AC%E6%8D%A2">class 组件与 Hook 之间的映射与转换</a><ul><li><a href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">生命周期</a></li><li><a href="#hooks-%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">Hooks 没有实现的生命周期钩子</a></li><li><a href="#%E8%BD%AC%E6%8D%A2%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F">转换实例变量</a></li><li><a href="#%E5%BC%BA%E5%88%B6%E6%9B%B4%E6%96%B0-hook-%E7%BB%84%E4%BB%B6">强制更新 Hook 组件</a></li><li><a href="#%E8%8E%B7%E5%8F%96%E6%97%A7%E7%9A%84-props-%E5%92%8C-state">获取旧的 props 和 state</a></li></ul></li></ul></li><li><a href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB">受控组件与非受控组件的区别</a></li><li><a href="#portals-%E6%98%AF%E4%BB%80%E4%B9%88">Portals 是什么?</a></li></ul></details><h2 id="React-是单向数据流还是双向数据流？它还有其他特点吗？"><a href="#React-是单向数据流还是双向数据流？它还有其他特点吗？" class="headerlink" title="React 是单向数据流还是双向数据流？它还有其他特点吗？"></a>React 是单向数据流还是双向数据流？它还有其他特点吗？</h2><p>React 是单向数据流，数据是从上向下流。它的其他主要特点时:</p><ul><li>数据驱动视图</li><li>声明式编写 UI</li><li>组件化开发</li></ul><h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><h3 id="React-通过什么方式来更新数据"><a href="#React-通过什么方式来更新数据" class="headerlink" title="React 通过什么方式来更新数据"></a>React 通过什么方式来更新数据</h3><p>React 是通过 <code>setState</code> 来更新数据的。调用多个 <code>setState</code> 不会立即更新数据，而会批量延迟更新后再将数据合并。</p><p>除了 <code>setState</code> 外还可以使用 <code>forceUpdate</code> 跳过当前组件的 <code>shouldComponentUpdate</code> diff，强制触发组件渲染(避免使用该方式)。</p><h3 id="React-不能直接修改-State-吗？"><a href="#React-不能直接修改-State-吗？" class="headerlink" title="React 不能直接修改 State 吗？"></a>React 不能直接修改 State 吗？</h3><ol><li>直接修改 state 不会触发组件的渲染。</li><li>若直接修改 state 引用的值，在实际使用时会导致错误的值出现</li><li>修改后的 state 可能会被后续调用的 <code>setState</code> 覆盖</li></ol><h3 id="setState-是同步还是异步的？"><a href="#setState-是同步还是异步的？" class="headerlink" title="setState 是同步还是异步的？"></a>setState 是同步还是异步的？</h3><p>出于性能的考虑，React 可能会把多个 <code>setState</code> 合并成一个调用。</p><p><code>React</code> 内有个 <code>batchUpdate(批量更新)</code> 的机制，在 React 可以控制的区域 (如组件生命周期、React 封装的事件处理器) 设置标识位 <code>isBatchingUpdate</code> 来决定是否触发更新。</p><p>比如在 React 中注册的 <code>onClick</code> 事件或是 <code>componentDidMount</code> 中直接使用 <code>setState</code> 都是异步的。若想拿到触发更新后的值，可以给 <code>setState</code> 第二个参数传递一个函数，该函数在<strong>数据更新后会触发的回调函数</strong>，函数的参数就是更新后最新的值。</p><p>不受 React 控制的代码快中使用 <code>setState</code> 是同步的，比如在 <code>setTimeout</code> 或是原生的事件监听器中使用。</p><h3 id="setState-小测"><a href="#setState-小测" class="headerlink" title="setState 小测"></a>setState 小测</h3><p>输出以下结果:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;1 --&gt;&quot;</span>, <span class="built_in">this</span>.state.count);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;2 --&gt;&quot;</span>, <span class="built_in">this</span>.state.count);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;3 --&gt;&quot;</span>, <span class="built_in">this</span>.state.count);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;4 --&gt;&quot;</span>, <span class="built_in">this</span>.state.count);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 --&gt; 0</span><br><span class="line">2 --&gt; 0</span><br><span class="line">3 --&gt; 2</span><br><span class="line">4 --&gt; 3</span><br></pre></td></tr></table></figure><p>解答: 调用 <code>setState</code> 后不会立即更新 state，开头两次调用会被异步合并调用，因此只有一次调用。一轮事件循环结束后，调用第 3、4 次 <code>setState</code>。由于在 <code>setTimeout</code> 中调用是同步更新的，因此都能正常的叠加数据。</p><h2 id="React-生命周期"><a href="#React-生命周期" class="headerlink" title="React 生命周期"></a>React 生命周期</h2><p>React 的生命周期主要是指组件<strong>在特定阶段会执行的函数</strong>。以下是 class 组件的部分<a target="_blank" rel="noopener" href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">生命周期图谱</a>:</p><img data-src="/blog/2020/10/31/react-retrospection/react-lifecycle.png" title="React 生命周期速查图"><p>从上图可以看出：React 的生命周期按照类型划分，可分为 <strong>挂载时(Mounting)、更新时(Updating)、卸载时(Unmounting)</strong> 。图中的生命周期函数效果如下:</p><h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor (构造函数)"></a>constructor (构造函数)</h3><ul><li><strong>触发条件</strong>: 组件初始化时</li><li><strong>是否可以使用 <code>setState</code></strong>: X</li><li><strong>使用场景</strong>: 初始化 <code>state</code> 或者对方法绑定 <code>this</code>。在构造函数中便于自动化测试。</li></ul><h3 id="static-getDerivedStateFromProps"><a href="#static-getDerivedStateFromProps" class="headerlink" title="static getDerivedStateFromProps"></a>static getDerivedStateFromProps</h3><blockquote><p>Tips: 不常用方法</p></blockquote><ul><li><strong>触发条件</strong>: 调用 <code>render</code> 函数之前</li><li><strong>是否可以使用 <code>setState</code></strong>: X</li><li><strong>函数行为</strong>: 函数可以返回一个对象用于更新组件内部的 <code>state</code> 数据，若返回 <code>null</code> 则什么都不更新。</li><li><strong>使用场景</strong>: 用于 state 依赖 props 的情况，也就是状态派生。值得注意的是派生 state 会导致代码冗余，并使组件难以维护。</li></ul><h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h3><blockquote><p>Tips: 不常用方法</p></blockquote><ul><li><strong>触发条件</strong>: 当 <code>props</code>/<code>state</code> 发生变化</li><li><strong>是否可以使用 <code>setState</code></strong>: X</li><li><strong>函数行为</strong>: 函数的返回值决定组件是否触发 <code>render</code>，返回值为 <code>true</code> 则触发渲染，反之则阻止渲染。(组件内不写该函数的话，则调用默认函数。默认函数只会返回 <code>true</code>，即只要 <code>props</code>/<code>state</code> 发生变化，就更新组件)</li><li><strong>使用场景</strong>: 组件的性能优化，仅仅是浅比较 props 和 state 的变化的话，可以使用内置的 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent">PureComponent</a> 来代替 <code>Component</code> 组件。</li></ul><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><ul><li><strong>触发条件</strong>: 渲染组件时</li><li><strong>是否可以使用 <code>setState</code></strong>: X</li><li><strong>函数行为</strong>: 函数的返回值决定视图的渲染效果</li><li><strong>使用场景</strong>: class 组件中唯一<strong>必须要实现</strong>的生命周期函数。</li></ul><h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><blockquote><p>Tips: 不常用方法</p></blockquote><ul><li><strong>触发条件</strong>: 在最近一次渲染输出（提交到 DOM 节点）之前调用</li><li><strong>是否可以使用 <code>setState</code></strong>: X</li><li><strong>函数行为</strong>: 函数的返回值将传入给 <code>componentDidUpdate</code> 第三个参数中。若只实现了该函数，但没有使用 <code>componentDidUpdate</code> 的话，React 将会在控制台抛出警告</li><li><strong>使用场景</strong>: 可以在组件发生更改之前从 DOM 中捕获一些信息（例如，列表的滚动位置）</li></ul><h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><ul><li><strong>触发条件</strong>: 组件挂载后（插入 DOM 树中）立即调用，该函数只会被触发一次</li><li><strong>是否可以使用 <code>setState</code></strong>: Y (可以<strong>直接调用</strong>，但会触发额外渲染)</li><li><strong>使用场景</strong>: 从网络请求中获取数据、订阅事件等</li></ul><h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><ul><li><strong>触发条件</strong>: 组件更新完毕后(首次渲染不会触发)</li><li><strong>是否可以使用 <code>setState</code></strong>: Y (更新语句须<strong>放在条件语句</strong>中，不然可能会造成死循环)</li><li><strong>使用场景</strong>: 对比新旧值的变化，进而判断是否需要发送网络请求。比如监听路由的变化</li></ul><h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><ul><li><strong>触发条件</strong>: 组件卸载及销毁之前直接调用</li><li><strong>是否可以使用 <code>setState</code></strong>: X</li><li><strong>使用场景</strong>: 清除 timer，取消网络请求或清除在 <code>componentDidMount</code> 中创建的订阅等</li></ul><h3 id="生命周期阶段"><a href="#生命周期阶段" class="headerlink" title="生命周期阶段"></a>生命周期阶段</h3><p>针对 React 生命周期中函数的调用顺序，笔者写了一个简易的 Demo 用于演示: <a target="_blank" rel="noopener" href="https://codesandbox.io/s/react-lifecycle-forked-2dvdg?file=/src/Parent.jsx">React 生命周期示例</a></p><p><strong>React 组件挂载阶段</strong>先后会触发 <code>constuctor</code>、<code>static getDerivedStateFromProps</code>、<code>render</code>、<code>componentDidMount</code> 函数。若 <code>render</code> 函数内还有子组件存在的话，则会进一步递归:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Parent]: constuctor</span><br><span class="line">[Parent]: static getDerivedStateFromProps</span><br><span class="line">[Parent]: render</span><br><span class="line">[Children]: constuctor</span><br><span class="line">[Children]: static getDerivedStateFromProps</span><br><span class="line">[Children]: render</span><br><span class="line">[Children]: componentDidMount</span><br><span class="line">[Children]: 挂载阶段结束!</span><br><span class="line">[Parent]: componentDidMount</span><br><span class="line">[Parent]: 挂载阶段结束!</span><br></pre></td></tr></table></figure><p><strong>React 组件更新阶段</strong>主要是组件的 props 或 state 发生变化时触发。若组件内还有子组件，则子组件会判断是否也需要触发更新。默认情况下 <code>component</code> 组件是只要父组件发生了变化，子组件也会跟着变化。以下是更新父组件 <code>state</code> 数据时所触发的生命周期函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Parent]: static getDerivedStateFromProps</span><br><span class="line">[Parent]: shouldComponentUpdate</span><br><span class="line">[Parent]: render</span><br><span class="line">[Children]: static getDerivedStateFromProps</span><br><span class="line">[Children]: shouldComponentUpdate</span><br><span class="line">[Children]: render</span><br><span class="line">[Children]: getSnapshotBeforeUpdate</span><br><span class="line">[Parent]: getSnapshotBeforeUpdate</span><br><span class="line">[Children]: componentDidUpdate</span><br><span class="line">[Children]: 更新阶段结束!</span><br><span class="line">[Parent]: componentDidUpdate</span><br><span class="line">[Parent]: 更新阶段结束!</span><br></pre></td></tr></table></figure><p>值得注意的是: 在本例 Demo 中没有给子组件传参，但子组件也触发了渲染。但从应用的角度上考虑，既然你子组件没有需要更新的东西，那就没有必要触发渲染吧？</p><p>因此 <code>Component</code> 组件上可以使用 <code>shouldComponentUpdate</code> 或者将 <code>Component</code> 组件替换为 <code>PureComponment</code> 组件来做优化。在生命周期图中也可以看到: <code>shouldComponentUpdate</code> 返回 <code>false</code> 时，将不再继续触发下面的函数。</p><p>有时你可能在某些情况下想主动触发渲染而又不被 <code>shouldComponentUpdate</code> 阻止渲染该怎么办呢？可以使用 <code>force­Update()</code> 跳过 <code>shouldComponentUpdate</code> 的 diff，进而渲染视图。(需要使用强制渲染的场景较少，一般不推荐这种方式进行开发)</p><p><strong>React 组件销毁阶段</strong>也没啥好说的了。父组件先触发销毁前的函数，再逐层向下触发:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[Parent]: componentWillUnmount</span><br><span class="line">[Parent]: 卸载阶段结束!</span><br><span class="line">[Children]: componentWillUnmount</span><br><span class="line">[Children]: 卸载阶段结束!</span><br></pre></td></tr></table></figure><h3 id="其他生命周期"><a href="#其他生命周期" class="headerlink" title="其他生命周期"></a>其他生命周期</h3><p>除了上图比较常见的生命周期外，还有一些过时的 API 就没有额外介绍了。因为它们可能在未来的版本会被移除：</p><ul><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillmount">UNSAFE_componentWillMount()</a>: 在组件即将被挂载到页面的时刻自动执行。应该使用 componentDidUpdate 来代替该函数。</li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillupdate">UNSAFE_componentWillUpdate()</a></li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillreceiveprops">UNSAFE_componentWillReceiveProps()</a>：当父组件某个 props 更新前，可以调用 <code>setState</code> 覆盖内部的某个 state。</li></ul><p>上图没有给出错误处理的情况，以下信息作为补充: 当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</p><ul><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromerror">static getDerivedStateFromError()</a></li><li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-component.html#componentdidcatch">componentDidCatch()</a></li></ul><h2 id="React-组件通信"><a href="#React-组件通信" class="headerlink" title="React 组件通信"></a>React 组件通信</h2><ol><li>父组件通过 props 给子组件传递数据。子组件通过触发父组件提供的回调函数来给父组件传递消息或数据</li><li><code>React.Context</code> 可以跨层级组件共享数据</li><li>自定义事件</li><li>引入 <code>Redux</code>/<code>Mobx</code> 之类的状态管理器</li></ol><h3 id="React-Context-怎么使用"><a href="#React-Context-怎么使用" class="headerlink" title="React.Context 怎么使用"></a>React.Context 怎么使用</h3><p><code>Context</code> 可以共享对于组件树而言是全局的数据，比如全局主题、首选语言等。使用方式如下：</p><ol><li><p><code>React.createContext</code> 函数用于生成 <code>Context</code> 对象。可以在创建时给 <code>Context</code> 设置默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">&#x27;light&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>Context</code> 对象中有一个 <code>Provider(提供者)</code> 组件，<code>Provider</code> 组件接受一个 <code>value</code> 属性用以将数据传递给消费组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ThemeContext.Provider value=<span class="string">&quot;dark&quot;</span>&gt;</span><br><span class="line">  &lt;page /&gt;</span><br><span class="line">&lt;/ThemeContext.Provider&gt;</span><br></pre></td></tr></table></figure></li><li><p>获取 <code>Context</code> 提供的值可以通过 <code>contextType</code> 或者 <code>Consumer(消费者)</code> 组件中获取。<code>contextType</code> 只能用于类组件，并且只能挂载一个 <code>Context</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.context;</span><br><span class="line">    <span class="comment">/* 在组件挂载完成后，使用 MyContext 的值执行一些有副作用的操作 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.context;</span><br><span class="line">    <span class="comment">/* 基于 MyContext 的值进行渲染 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyClass.contextType = MyContext;</span><br></pre></td></tr></table></figure><p>若想给组件挂载多个 <code>Context</code>, 或者在函数组件内使用 <code>Context</code> 可以使用 <code>Consumer</code> 组件:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ThemeContext.Consumer&gt;</span><br><span class="line">  &#123;<span class="function"><span class="params">theme</span> =&gt;</span> (</span><br><span class="line">    &lt;UserContext.Consumer&gt;</span><br><span class="line">      &#123;<span class="function"><span class="params">user</span> =&gt;</span> (</span><br><span class="line">        &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/UserContext.Consumer&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/ThemeContext.Consumer&gt;</span><br></pre></td></tr></table></figure></li></ol><p><code>Context</code> 通常适用于传递较为简单的数据信息，若数据太过复杂，还是需要引入状态管理(<code>Redux</code>/<code>Mbox</code>)。</p><h2 id="函数组件是什么？与类组件有什么区别？"><a href="#函数组件是什么？与类组件有什么区别？" class="headerlink" title="函数组件是什么？与类组件有什么区别？"></a>函数组件是什么？与类组件有什么区别？</h2><p>函数组件本质上是一个纯函数，它接受 props 属性，最后返回 JSX。</p><p>与类组件的差别在于: 它没有实例、不能通过 <code>extends</code> 继承于其他方法、也没有生命周期和 <code>state</code>。以前函数组件常作为无状态组件，React 16.8+ 可以引入 <code>Hooks</code> 为函数组件支持状态和副作用操作。</p><h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><h3 id="Hook-vs-class"><a href="#Hook-vs-class" class="headerlink" title="Hook vs class"></a>Hook vs class</h3><p><strong>类组件的不足</strong>:</p><ul><li>状态逻辑复用难，缺少复用机制。渲染属性和高阶组件导致层级冗余。</li><li>组件趋向复杂难以维护。生命周期函数混杂不相干逻辑，相干逻辑分散在不同生命周期中。</li><li>this 指向令人困扰。内联函数过度创建新句柄，类成员函数不能保证 this。</li></ul><p><strong>Hooks 的优点</strong>:</p><ul><li>自定义 Hook 方便复用状态逻辑</li><li>副作用的关注点分离</li><li>函数组件没有 this 问题</li></ul><p><strong>Hooks 现有的不足</strong>:</p><ul><li>不能完全取代 class 组件的生命周期，部分不常用的生命周期暂时没有实现。</li><li>Hooks 的运作方式带来了一定的学习成本，需要转换现有的编程思维，增加了心智负担。</li></ul><h3 id="Hooks-的使用"><a href="#Hooks-的使用" class="headerlink" title="Hooks 的使用"></a>Hooks 的使用</h3><blockquote><p>描述 Hooks 有哪些常用的方法和大致用途</p></blockquote><ol><li><p><code>useState</code>: 使函数组件支持设置 <code>state</code> 数据，可用于代替类组件的 <code>constructor</code> 函数。</p></li><li><p><code>useEffect</code>: 使函数组件支持操作副作用 (effect) 的能力，Hook 第二个参数是 effect 的依赖项。当依赖项是空时，effect 函数仅会在组件挂载后执行一遍。若有一个或多个依赖项时，只要任意一个依赖项发生变化，就会触发 effect 函数的执行。effect 函数里可以做一些如获取页面数据、订阅事件等操作。</p><p>除此之外，<code>useEffect</code> 还可以返回一个函数用于做清除操作，这个清除操作时可选的。常用于清理订阅事件、DOM 事件等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定 DOM 事件</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>, handleClick);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// useEffect 回调函数的返回值是函数的话，当组件卸载时会执行该函数</span></span><br><span class="line">   <span class="comment">// 若没有需要清除的东西，则可以忽略这一步骤</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">document</span>.removeEventListener(<span class="string">&#x27;click&#x27;</span>, handleClick);</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;, [handleClick]);</span><br></pre></td></tr></table></figure></li><li><p><code>useLayoutEffect</code>: <code>useEffect</code> 的 effect 执行的时机是在浏览器完成布局和绘制<strong>之后</strong>会延迟调用。若想要 DOM 变更的同时同步执行 effect 的话可以使用 <code>useLayoutEffect</code>。它们之间只是执行的时机不同，其他都一样。</p></li><li><p><code>useContext</code>: 接收一个 <code>Context</code> 对象，并返回 <code>Context</code> 的当前值。相当于类组件的 <code>static contextType = MyContext</code>。</p></li><li><p><code>useReducer</code> 是 <code>useState</code> 的代替方案，它的工作方式有点类似于 <code>Redux</code>，通过函数来操作 state。适合 <code>state</code> 逻辑较为复杂且包含多个子值，或是新的 <code>state</code> 依赖于旧的 <code>state</code> 的场景。</p></li><li><p><code>useMemo</code> 主要用于性能优化，它可以缓存变量的值，避免每次组件更新后都需要重复计算值。</p></li><li><p><code>useCallbck</code> 用于缓存函数，避免函数被重复创建，它是 <code>useMemo</code> 的语法糖。<code>useCallback(fn, deps)</code> 的效果相当于是 <code>useMemo(() =&gt; fn, deps)</code>。</p></li></ol><h3 id="Hook-之间的一些差异"><a href="#Hook-之间的一些差异" class="headerlink" title="Hook 之间的一些差异"></a>Hook 之间的一些差异</h3><ol><li><p><strong>React.memo 与 React.useMemo</strong>：</p><p><code>memo</code> 针对一个组件的渲染是否重复执行，<code>useMemo</code> 定义一段函数逻辑是否重复执行。</p></li><li><p><strong>React.useMemo 与 React.useCallback</strong>：</p><p><code>useMemo(() =&gt; fn)</code> 返回的是一个函数，将等同于 <code>useCallback(fn)</code>。</p></li><li><p><strong>React.useStatus 与 React.useRef</strong>：</p><p><code>React.useStatus</code> 相当于类的 <code>state</code>；<code>React.useRef</code> 相当于类的内部属性。前者参与渲染，后者的修改不会触发渲染。</p></li></ol><h3 id="自定义-Hook-的使用"><a href="#自定义-Hook-的使用" class="headerlink" title="自定义 Hook 的使用"></a>自定义 Hook 的使用</h3><p>自定义 Hook 的命名规则是以 <code>use</code> 开头的函数，比如 <code>useLocalStorage</code> 就符合自定义 Hook 的命名规范。<br>使用自定义 Hook 的场景有很多，如表单处理、动画、订阅声明、定时器等等可复用的逻辑都能通过自定义 Hook 来抽象实现。</p><p>在自定义 Hook 中，可以使用 Hooks 函数将可复用的逻辑和功能提取出来，并将内部的 <code>state</code> 或操作的方法从自定义 Hook 函数中返回出来。函数组件使用时就可以像调用普通函数一祥调用自定义 Hook 函数, 并将自定义 Hook 返回的 <code>state</code> 和操作方法通过解构保存到变量中。</p><p>下面是 <a target="_blank" rel="noopener" href="https://usehooks.com/useLocalStorage/">useLocalStorage</a> 的实现，它将 state 同步到本地存储，以使其在页面刷新后保持不变。 用法与 useState 相似，不同之处在于我们传入了本地存储键，以便我们可以在页面加载时默认为该值，而不是指定的初始值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Similar to useState but first arg is key to the value in local storage.</span></span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useLocalStorage(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">&quot;text&quot;</span></span><br><span class="line">        placeholder=<span class="string">&quot;Enter your name&quot;</span></span><br><span class="line">        value=&#123;name&#125;</span><br><span class="line">        onChange=&#123;<span class="function"><span class="params">e</span> =&gt;</span> setName(e.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hook</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useLocalStorage</span>(<span class="params">key, initialValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// State to store our value</span></span><br><span class="line">  <span class="comment">// Pass initial state function to useState so logic is only executed once</span></span><br><span class="line">  <span class="keyword">const</span> [storedValue, setStoredValue] = useState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Get from local storage by key</span></span><br><span class="line">      <span class="keyword">const</span> item = <span class="built_in">window</span>.localStorage.getItem(key);</span><br><span class="line">      <span class="comment">// Parse stored json or if none return initialValue</span></span><br><span class="line">      <span class="keyword">return</span> item ? <span class="built_in">JSON</span>.parse(item) : initialValue;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// If error also return initialValue</span></span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">      <span class="keyword">return</span> initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a wrapped version of useState&#x27;s setter function that ...</span></span><br><span class="line">  <span class="comment">// ... persists the new value to localStorage.</span></span><br><span class="line">  <span class="keyword">const</span> setValue = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allow value to be a function so we have same API as useState</span></span><br><span class="line">      <span class="keyword">const</span> valueToStore =</span><br><span class="line">        value <span class="keyword">instanceof</span> <span class="built_in">Function</span> ? value(storedValue) : value;</span><br><span class="line">      <span class="comment">// Save state</span></span><br><span class="line">      setStoredValue(valueToStore);</span><br><span class="line">      <span class="comment">// Save to local storage</span></span><br><span class="line">      <span class="built_in">window</span>.localStorage.setItem(key, <span class="built_in">JSON</span>.stringify(valueToStore));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// A more advanced implementation would handle the error case</span></span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [storedValue, setValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意: 自定义 Hook 函数在定义时，也可以使用另一个自定义 Hook 函数。</strong></p><h3 id="Hook-使用约束"><a href="#Hook-使用约束" class="headerlink" title="Hook 使用约束"></a>Hook 使用约束</h3><ol><li>只能在<strong>函数组件最顶层</strong>调用 Hook，不能在循环、条件判断或子函数中调用。</li><li>只能在<strong>函数组件</strong>或者是<strong>自定义 Hook 函数</strong>中调用，普通的 js 函数不能使用。</li></ol><h3 id="class-组件与-Hook-之间的映射与转换"><a href="#class-组件与-Hook-之间的映射与转换" class="headerlink" title="class 组件与 Hook 之间的映射与转换"></a>class 组件与 Hook 之间的映射与转换</h3><p>函数组件相比 class 组件会缺少很多功能，但大多可以通过 Hook 的方式来实现。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ul><li><p><strong>constructor</strong>：class 组件的构造函数一般是用于初始化 <code>state</code> 数据或是给事件绑定 <code>this</code> 指向的。函数组件内没有 this 指向的问题，因此可以忽略。而 <code>state</code> 可以通过 <code>useState</code>/<code>useReducer</code> 来实现。</p></li><li><p><strong>getDerivedStateFromProps</strong>：<code>getDerivedStateFromProps</code> 一般用于在组件 props 发生变化时派生 <code>state</code>。Hooks 实现同等效果如下:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ScrollView</span>(<span class="params">&#123;row&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isScrollingDown, setIsScrollingDown] = useState(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">const</span> [prevRow, setPrevRow] = useState(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (row !== prevRow) &#123;</span><br><span class="line">    <span class="comment">// Row 自上次渲染以来发生过改变。更新 isScrollingDown。</span></span><br><span class="line">    setIsScrollingDown(prevRow !== <span class="literal">null</span> &amp;&amp; row &gt; prevRow);</span><br><span class="line">    setPrevRow(row);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Scrolling down: <span class="subst">$&#123;isScrollingDown&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>shouldComponentUpdate</strong>: 使用 <code>React.memo</code> 应用到函数组件中后，当 props 发生变化时，会对 props 的新旧值进行前对比，相当于是 <code>PureComponent</code> 的功能。如果你还想自己定义比较函数的话，可以给 <code>React.memo</code> 的第二个参数传一个函数，若函数返回 <code>true</code> 则跳过更新。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = React.memo(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>&#123;props.text&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>render</strong>: 函数组件本身就是一个 <code>render</code> 函数。</p></li><li><p><strong>componentDidMount / componentDidUpdate / componentWillUnmount</strong>:</p><p><code>useEffect</code> 第二个参数的依赖项为空时，相当于 <code>componentDidMount</code>，组件挂载后只会执行一次。每个 <code>useEffect</code> 返回的函数相当于是 <code>componentWillUnmount</code> 同等效果的操作。若有依赖，则 effect 函数相当于是 <code>componentDidUpdate</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有依赖项，仅执行一次</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相当于 componentWillUnmount</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若有依赖项，相当于 componentDidUpdate</span></span><br><span class="line"><span class="comment">// 当 page 发生变化时会触发 effect 函数</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fetchList(&#123; page &#125;);</span><br><span class="line">&#125;, [page]);</span><br></pre></td></tr></table></figure></li></ul><h4 id="Hooks-没有实现的生命周期钩子"><a href="#Hooks-没有实现的生命周期钩子" class="headerlink" title="Hooks 没有实现的生命周期钩子"></a>Hooks 没有实现的生命周期钩子</h4><ul><li>getSnapshotBeforeUpdate</li><li>getDerivedStateFromError</li><li>componentDidCatch</li></ul><h4 id="转换实例变量"><a href="#转换实例变量" class="headerlink" title="转换实例变量"></a>转换实例变量</h4><p>使用 <code>useRef</code> 设置可变数据。</p><h4 id="强制更新-Hook-组件"><a href="#强制更新-Hook-组件" class="headerlink" title="强制更新 Hook 组件"></a>强制更新 Hook 组件</h4><p>设置一个<strong>没有实际作用</strong>的 <code>state</code>，然后强制更新 <code>state</code> 的值触发渲染。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Todo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 使用 useState，用随机数据更新也行</span></span><br><span class="line">  <span class="keyword">const</span> [ignored, forceUpdate] = useReducer(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    forceUpdate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">click</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span>强制更新组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取旧的-props-和-state"><a href="#获取旧的-props-和-state" class="headerlink" title="获取旧的 props 和 state"></a>获取旧的 props 和 state</h4><p>可以通过 <code>useRef</code> 来保存数据，因为渲染时不会覆盖掉可变数据。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevCountRef = useRef();</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    prevCountRef.current = count;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevCount = prevCountRef.current;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Now: &#123;count&#125;, before: &#123;prevCount&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="受控组件与非受控组件的区别"><a href="#受控组件与非受控组件的区别" class="headerlink" title="受控组件与非受控组件的区别"></a>受控组件与非受控组件的区别</h2><p>受控组件主要是指表单的值受到 <code>state</code> 的控制，它需要自行监听 <code>onChange</code> 事件来更新 <code>state</code>。</p><p>由于受控组件每次都要编写事件处理器才能更新 <code>state</code> 数据、可能会有点麻烦，React 提供另一种代替方案是<strong>非受控组件</strong>。</p><p>非受控组件将<strong>真实数据储存在 DOM 节点</strong>中，它可以为表单项设置默认值，不需要手动更新数据。当需要用到表单数据时再通过 <code>ref</code> 从 DOM 节点中取出数据即可。</p><p><strong>注意: 多数情况下React 推荐编写受控组件。</strong></p><p>扩展资料: <a target="_blank" rel="noopener" href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/">受控和非受控制使用场景的选择</a></p><h2 id="Portals-是什么"><a href="#Portals-是什么" class="headerlink" title="Portals 是什么?"></a>Portals 是什么?</h2><p><code>Portals</code> 就像个传送门，它可以将子节点渲染到存在于父组件以外的 DOM 节点的方案。</p><p>比如 <code>Dialog</code> 是一个全局组件，按照传统渲染组件的方式，<code>Dialog</code> 可能会受到其容器 css 的影响。因此可以使用 <code>Portals</code> 让组件在视觉上渲染到 <code>&lt;body&gt;</code> 中，使其样式不受 <code>overflow: hidden</code> 或 <code>z-index</code> 的影响。</p></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-date">2020-11-04</div><div class="popular-posts-title"><a href="/blog/2020/11/04/react-retrospection-2/" rel="bookmark">React 知识回顾 (优化篇)</a></div></li><li class="popular-posts-item"><div class="popular-posts-date">2018-01-23</div><div class="popular-posts-title"><a href="/blog/2018/01/23/JavaScript-你为什么会放弃JQuery而选用Vue-React-Angular进行开发/" rel="bookmark">为什么我们要选用 Vue/React/Angular 进行开发</a></div></li><li class="popular-posts-item"><div class="popular-posts-date">2017-11-17</div><div class="popular-posts-title"><a href="/blog/2017/11/17/Javascript深入解析-裁剪图片效果/" rel="bookmark">实现图片裁剪的效果</a></div></li><li class="popular-posts-item"><div class="popular-posts-date">2017-11-29</div><div class="popular-posts-title"><a href="/blog/2017/11/29/Vue-v-for-遍历绑定toggle-icon-动态切换action/" rel="bookmark">vue 遍历绑定toggle icon, 动态切换action</a></div></li><li class="popular-posts-item"><div class="popular-posts-date">2017-07-16</div><div class="popular-posts-title"><a href="/blog/2017/07/16/array-method-test/" rel="bookmark">[JavaScript] 数组方法深入研究与练习</a></div></li></ul><div class="reward-container"><div></div><div style="color:grey">「请笔者喝杯奶茶鼓励一下」</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>Donate</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/blog/images/qrcode/wechatpay.png" alt="anran758 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/blog/images/qrcode/alipay.png" alt="anran758 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>anran758</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://anran758.github.io/blog/2020/10/31/react-retrospection/" title="React 知识回顾 (使用篇)">https://anran758.github.io/blog/2020/10/31/react-retrospection/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="https://zhuanlan.zhihu.com/c_1147180666474176512"><span class="icon"><i class="fab fa-zhihu"></i> </span><span class="label">知乎专栏</span></a></div><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/blog/tags/JavaScript/" rel="tag"># JavaScript</a> <a href="/blog/tags/React/" rel="tag"># React</a></div><div class="post-widgets"><div class="wp_rating"><div id="wpac-rating"></div></div></div><div class="post-nav"><div class="post-nav-item"><a href="/blog/2020/09/27/hexo-issue/" rel="prev" title="Hexo 常见问题解决方案"><i class="fa fa-chevron-left"></i> Hexo 常见问题解决方案</a></div><div class="post-nav-item"><a href="/blog/2020/11/04/react-retrospection-2/" rel="next" title="React 知识回顾 (优化篇)">React 知识回顾 (优化篇) <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="tabs tabs-comment"><ul class="nav-tabs"><li class="tab"><a href="#comment-disqus">disqus</a></li><li class="tab"><a href="#comment-gitalk">gitalk</a></li></ul><div class="tab-content"><div class="tab-pane disqus" id="comment-disqus"><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div></div><div class="tab-pane gitalk" id="comment-gitalk"><div class="comments" id="gitalk-container"></div></div></div></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E6%98%AF%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BF%98%E6%98%AF%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%9F%E5%AE%83%E8%BF%98%E6%9C%89%E5%85%B6%E4%BB%96%E7%89%B9%E7%82%B9%E5%90%97%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">React 是单向数据流还是双向数据流？它还有其他特点吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setState"><span class="nav-number">2.</span> <span class="nav-text">setState</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E6%9D%A5%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.</span> <span class="nav-text">React 通过什么方式来更新数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React-%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9-State-%E5%90%97%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">React 不能直接修改 State 吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setState-%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84%EF%BC%9F"><span class="nav-number">2.3.</span> <span class="nav-text">setState 是同步还是异步的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setState-%E5%B0%8F%E6%B5%8B"><span class="nav-number">2.4.</span> <span class="nav-text">setState 小测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.</span> <span class="nav-text">React 生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#constructor-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">constructor (构造函数)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static-getDerivedStateFromProps"><span class="nav-number">3.2.</span> <span class="nav-text">static getDerivedStateFromProps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shouldComponentUpdate"><span class="nav-number">3.3.</span> <span class="nav-text">shouldComponentUpdate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#render"><span class="nav-number">3.4.</span> <span class="nav-text">render</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getSnapshotBeforeUpdate"><span class="nav-number">3.5.</span> <span class="nav-text">getSnapshotBeforeUpdate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#componentDidMount"><span class="nav-number">3.6.</span> <span class="nav-text">componentDidMount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#componentDidUpdate"><span class="nav-number">3.7.</span> <span class="nav-text">componentDidUpdate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#componentWillUnmount"><span class="nav-number">3.8.</span> <span class="nav-text">componentWillUnmount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%98%B6%E6%AE%B5"><span class="nav-number">3.9.</span> <span class="nav-text">生命周期阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.10.</span> <span class="nav-text">其他生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="nav-number">4.</span> <span class="nav-text">React 组件通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#React-Context-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">React.Context 怎么使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%8E%E7%B1%BB%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">函数组件是什么？与类组件有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hooks"><span class="nav-number">6.</span> <span class="nav-text">Hooks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Hook-vs-class"><span class="nav-number">6.1.</span> <span class="nav-text">Hook vs class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hooks-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.2.</span> <span class="nav-text">Hooks 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hook-%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%AE%E5%BC%82"><span class="nav-number">6.3.</span> <span class="nav-text">Hook 之间的一些差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Hook-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.4.</span> <span class="nav-text">自定义 Hook 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hook-%E4%BD%BF%E7%94%A8%E7%BA%A6%E6%9D%9F"><span class="nav-number">6.5.</span> <span class="nav-text">Hook 使用约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-%E7%BB%84%E4%BB%B6%E4%B8%8E-Hook-%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="nav-number">6.6.</span> <span class="nav-text">class 组件与 Hook 之间的映射与转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">6.6.1.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hooks-%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="nav-number">6.6.2.</span> <span class="nav-text">Hooks 没有实现的生命周期钩子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="nav-number">6.6.3.</span> <span class="nav-text">转换实例变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E6%9B%B4%E6%96%B0-Hook-%E7%BB%84%E4%BB%B6"><span class="nav-number">6.6.4.</span> <span class="nav-text">强制更新 Hook 组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E6%97%A7%E7%9A%84-props-%E5%92%8C-state"><span class="nav-number">6.6.5.</span> <span class="nav-text">获取旧的 props 和 state</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">受控组件与非受控组件的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Portals-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">8.</span> <span class="nav-text">Portals 是什么?</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="anran758" src="https://avatars3.githubusercontent.com/u/23024075?s=96&v=4"><p class="site-author-name" itemprop="name">anran758</p><div class="site-description" itemprop="description">web 开发的碎碎念</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/blog/archives/"><span class="site-state-item-count">59</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/blog/categories/"><span class="site-state-item-count">23</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/blog/tags/"><span class="site-state-item-count">88</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/anran758" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anran758" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://weibo.com/u/3833726651" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3833726651" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a> </span><span class="links-of-author-item"><a href="https://segmentfault.com/u/anran758" title="Segmentfault → https:&#x2F;&#x2F;segmentfault.com&#x2F;u&#x2F;anran758" rel="noopener" target="_blank"><i class="fab fa-skype fa-fw"></i>Segmentfault</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> 推荐阅读</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://www.zhangxinxu.com/" title="http:&#x2F;&#x2F;www.zhangxinxu.com&#x2F;" rel="noopener" target="_blank">张鑫旭</a></li><li class="links-of-blogroll-item"><a href="https://tan90qian.github.io/blog/" title="https:&#x2F;&#x2F;tan90qian.github.io&#x2F;blog&#x2F;" rel="noopener" target="_blank">Tan90Qian's blog</a></li><li class="links-of-blogroll-item"><a href="http://www.alloyteam.com/" title="http:&#x2F;&#x2F;www.alloyteam.com&#x2F;" rel="noopener" target="_blank">Alloyteam</a></li></ul></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> 常用网站</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://caniuse.com/" title="https:&#x2F;&#x2F;caniuse.com&#x2F;" rel="noopener" target="_blank">Caniuse(CSS兼容性)</a></li><li class="links-of-blogroll-item"><a href="https://developer.mozilla.org/zh-CN/" title="https:&#x2F;&#x2F;developer.mozilla.org&#x2F;zh-CN&#x2F;" rel="noopener" target="_blank">MDN(web 文档)</a></li><li class="links-of-blogroll-item"><a href="https://codepen.io/" title="https:&#x2F;&#x2F;codepen.io&#x2F;" rel="noopener" target="_blank">codepen</a></li><li class="links-of-blogroll-item"><a href="https://tinypng.com/" title="https:&#x2F;&#x2F;tinypng.com&#x2F;" rel="noopener" target="_blank">Tinypng(图片压缩)</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2017 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">anran758</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">295k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:09</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=5d560b378f0db5fa" async></script></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>!function(){function e(e){return e=encodeURI(e),document.getElementById(e).querySelector(".leancloud-visitors-count")}let{app_id:t,app_key:o,server_url:n}={enable:!0,app_id:"pzA3EVFcmmGjhOfofaeSXDdr-MdYXbMMI",app_key:"YQgLRTjAQ5uE0S4T6dKqeS8U",server_url:null,security:!0};function r(n){var r=(e,r,l)=>fetch(`${n}/1.1${r}`,{method:e,headers:{"X-LC-Id":t,"X-LC-Key":o,"Content-Type":"application/json"},body:JSON.stringify(l)});if(CONFIG.page.isPost){if(CONFIG.hostname!==location.hostname)return;!function(t){var o=document.querySelector(".leancloud_visitors"),n=decodeURI(o.id);o.dataset.flagTitle,t("get","/classes/Counter?where="+encodeURIComponent(JSON.stringify({url:n}))).then(e=>e.json()).then(({results:o})=>{if(o.length>0){var r=o[0];e(n).innerText=r.time+1,t("put","/classes/Counter/"+r.objectId,{time:{__op:"Increment",amount:1}}).catch(e=>{console.error("Failed to save visitor count",e)})}else e(n).innerText="Counter not initialized! More info at console err msg.",console.error("ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.")}).catch(e=>{console.error("LeanCloud Counter Error",e)})}(r)}else document.querySelectorAll(".post-title-link").length>=1&&function(t){var o=[...document.querySelectorAll(".leancloud_visitors")].map(e=>decodeURI(e.id));t("get","/classes/Counter?where="+encodeURIComponent(JSON.stringify({url:{$in:o}}))).then(e=>e.json()).then(({results:t})=>{for(let n of o){let o=t.find(e=>e.url===n);e(n).innerText=o?o.time:0}}).catch(e=>{console.error("LeanCloud Counter Error",e)})}(r)}let l="-MdYXbMMI"!==t.slice(-9)?n:`https://${t.slice(0,8).toLowerCase()}.api.lncldglobal.com`;l?r(l):fetch("https://app-router.leancloud.cn/2/route?appId="+t).then(e=>e.json()).then(({api_server:e})=>{r("https://"+e)})}()</script></div></footer></div><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/blog/js/utils.js"></script><script src="/blog/js/schemes/muse.js"></script><script src="/blog/js/next-boot.js"></script><script src="/blog/js/bookmark.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>CONFIG.page.isPost&&(wpac_init=window.wpac_init||[],wpac_init.push({widget:"Rating",id:20378,el:"wpac-rating",color:"fc6423"}),function(){if(!("WIDGETPACK_LOADED"in window)){WIDGETPACK_LOADED=!0;var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//embed.widgetpack.com/widget.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t.nextSibling)}}())</script><script src="/blog/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js",()=>{mermaid.initialize({theme:"default",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><script>function loadCount(){var d=document,n=d.createElement("script");n.src="https://anran758.disqus.com/count.js",n.id="dsq-count-scr",(d.head||d.body).appendChild(n)}window.addEventListener("load",loadCount,!1)</script><script>var disqus_config=function(){this.page.url="https://anran758.github.io/blog/2020/10/31/react-retrospection/",this.page.identifier="2020/10/31/react-retrospection/",this.page.title="React 知识回顾 (使用篇)"};NexT.utils.loadComments(document.querySelector("#disqus_thread"),()=>{if(window.DISQUS)DISQUS.reset({reload:!0,config:disqus_config});else{var e=document,t=e.createElement("script");t.src="https://anran758.disqus.com/embed.js",t.setAttribute("data-timestamp",""+ +new Date),(e.head||e.body).appendChild(t)}})</script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script>NexT.utils.loadComments(document.querySelector("#gitalk-container"),()=>{NexT.utils.getScript("//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js",()=>{new Gitalk({clientID:"a35e4aa0db5b5a7bcc2f",clientSecret:"a19ef2a9debab8747a6e723c1eff1141213fe101",repo:"gitment-comments",owner:"anran758",admin:["anran758"],id:"a4d136da15409bd556cf5822c6e56e0e",language:"",distractionFreeMode:!0}).render("gitalk-container")},window.Gitalk)})</script></body></html>